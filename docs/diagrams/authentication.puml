@startuml Authentication Flow
!theme plain
skinparam sequenceMessageAlign center

title JWT Authentication & Authorization Flow

actor "Client" as client
participant "API Gateway" as gateway
participant "Auth Middleware" as authmw
participant "JWT Service" as jwt
participant "Auth Service\n(Backend)" as authsvc
participant "User Service\n(Backend)" as usersvc
database "MongoDB" as db
database "Redis Cache" as redis

== User Registration ==

client -> gateway : POST /api/v1/auth/register\n{email, password, name}
activate gateway

gateway -> gateway : Apply public route middlewares\n(no auth required)
gateway -> authsvc : Forward registration request (gRPC)
activate authsvc

authsvc -> authsvc : Validate input\nHash password (bcrypt)
authsvc -> db : Create user document
activate db
db --> authsvc : User created
deactivate db

authsvc --> gateway : Success response\n{userId, email}
deactivate authsvc

gateway --> client : 201 Created\n{userId, email}
deactivate gateway

== User Login ==

client -> gateway : POST /api/v1/auth/login\n{email, password}
activate gateway

gateway -> gateway : Apply public route middlewares
gateway -> authsvc : Forward login request (gRPC)
activate authsvc

authsvc -> db : Find user by email
activate db
db --> authsvc : User document
deactivate db

authsvc -> authsvc : Verify password hash
alt Password Invalid
    authsvc --> gateway : 401 Unauthorized
    gateway --> client : 401 Unauthorized\n{error: "Invalid credentials"}
    deactivate authsvc
    deactivate gateway
else Password Valid
    
    authsvc -> authsvc : Generate JWT tokens
    note right
      Access Token (15 min):
      - userId
      - email
      - tenantId (if applicable)
      - roles
      
      Refresh Token (7 days):
      - userId
      - tokenId (for revocation)
    end note
    
    authsvc -> redis : Store refresh token\nSET refresh_token:{tokenId}\nEXP 7 days
    activate redis
    redis --> authsvc : OK
    deactivate redis
    
    authsvc --> gateway : Success response
    deactivate authsvc
    
    gateway --> client : 200 OK\n{access_token, refresh_token, expiresIn}
    deactivate gateway
end

== Authenticated Request (Protected Route) ==

client -> gateway : GET /api/v1/users\nHeader: Authorization: Bearer {access_token}
activate gateway

gateway -> authmw : Process middleware
activate authmw

authmw -> authmw : Extract token from\nAuthorization header
alt Token Missing
    authmw --> client : 401 Unauthorized\n{error: "Missing token"}
    deactivate authmw
    deactivate gateway
else Token Present
    
    authmw -> jwt : Validate JWT token
    activate jwt
    
    jwt -> jwt : Verify signature\nCheck expiration\nValidate claims
    
    alt Token Invalid or Expired
        jwt --> authmw : Invalid token
        deactivate jwt
        authmw --> client : 401 Unauthorized\n{error: "Invalid or expired token"}
        deactivate authmw
        deactivate gateway
    else Token Valid
        
        jwt --> authmw : Token claims\n{userId, email, tenantId, roles}
        deactivate jwt
        
        authmw -> authmw : Extract user info\nAdd to request context
        note right
          Context contains:
          - userId
          - email  
          - tenantId
          - roles
          - correlationId
        end note
        
        authmw -> gateway : Continue with context
        deactivate authmw
        
        gateway -> usersvc : Forward request (gRPC)\nwith user context
        activate usersvc
        
        usersvc -> usersvc : Check authorization\n(RBAC - Role-Based Access Control)
        alt Insufficient Permissions
            usersvc --> gateway : 403 Forbidden
            gateway --> client : 403 Forbidden\n{error: "Insufficient permissions"}
            deactivate usersvc
            deactivate gateway
        else Authorized
            
            usersvc -> db : Query users\n(filtered by tenantId if multi-tenant)
            activate db
            db --> usersvc : User list
            deactivate db
            
            usersvc --> gateway : Success response\n{users: [...]}
            deactivate usersvc
            
            gateway --> client : 200 OK\n{users: [...]}
            deactivate gateway
        end
    end
end

== Token Refresh ==

client -> gateway : POST /api/v1/auth/refresh\n{refresh_token}
activate gateway

gateway -> authsvc : Forward refresh request (gRPC)
activate authsvc

authsvc -> authsvc : Validate refresh token JWT
alt Token Invalid
    authsvc --> gateway : 401 Unauthorized
    gateway --> client : 401 Unauthorized\n{error: "Invalid refresh token"}
    deactivate authsvc
    deactivate gateway
else Token Valid
    
    authsvc -> redis : Check token revocation\nGET refresh_token:{tokenId}
    activate redis
    
    alt Token Revoked or Not Found
        redis --> authsvc : Token not found
        deactivate redis
        authsvc --> gateway : 401 Unauthorized
        gateway --> client : 401 Unauthorized\n{error: "Token revoked"}
        deactivate authsvc
        deactivate gateway
    else Token Active
        redis --> authsvc : Token exists
        deactivate redis
        
        authsvc -> authsvc : Generate new access token\n(15 min expiration)
        
        authsvc --> gateway : Success response
        deactivate authsvc
        
        gateway --> client : 200 OK\n{access_token, expiresIn}
        deactivate gateway
    end
end

== Logout ==

client -> gateway : POST /api/v1/auth/logout\nHeader: Authorization: Bearer {access_token}
activate gateway

gateway -> authmw : Validate token
activate authmw
authmw -> jwt : Validate JWT
activate jwt
jwt --> authmw : Valid token + claims
deactivate jwt
authmw -> gateway : Continue
deactivate authmw

gateway -> authsvc : Forward logout request (gRPC)
activate authsvc

authsvc -> redis : Revoke refresh token\nDEL refresh_token:{tokenId}
activate redis
redis --> authsvc : OK
deactivate redis

authsvc -> redis : Blacklist access token\nSET blacklist:{tokenJti}\nEXP remainingTtl
activate redis
note right
  Access tokens cannot be truly revoked,
  but can be blacklisted until expiration
end note
redis --> authsvc : OK
deactivate redis

authsvc --> gateway : Success response
deactivate authsvc

gateway --> client : 200 OK\n{message: "Logged out successfully"}
deactivate gateway

== Multi-Tenant Context ==

note over client, db
  For multi-tenant systems, the JWT includes tenantId.
  All backend services filter data by tenantId automatically.
  
  This ensures tenant isolation at the application level:
  - Users can only access their tenant's data
  - Queries are automatically scoped to tenantId
  - Cross-tenant access is prevented by the gateway
end note

@enduml
