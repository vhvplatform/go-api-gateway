@startuml Circuit Breaker Pattern
!theme plain

title Circuit Breaker - Fault Tolerance Pattern

participant "API Gateway\nHandler" as handler
participant "Circuit Breaker\nManager" as manager
participant "Circuit Breaker\n(Auth Service)" as breaker_auth
participant "Circuit Breaker\n(User Service)" as breaker_user
participant "State Machine" as state
participant "Auth Service\n(Backend)" as authsvc
participant "User Service\n(Backend)" as usersvc
participant "Metrics" as metrics

== Initialization ==

handler -> manager : GetBreaker("auth-service")
activate manager
manager -> manager : Check if breaker exists

alt Breaker Not Found
    manager -> breaker_auth : Create new circuit breaker
    activate breaker_auth
    breaker_auth -> state : Initialize state machine
    activate state
    state -> state : State: CLOSED\nFailure count: 0\nSuccess count: 0
    note right
      Circuit Breaker Settings:
      - Name: auth-service
      - Max Requests: 3 (half-open state)
      - Interval: 1 minute
      - Timeout: 30 seconds
      - Ready to Trip:
        * Min 3 requests
        * Failure ratio >= 60%
    end note
    state --> breaker_auth : Initial state
    deactivate state
    breaker_auth --> manager : Breaker created
    manager -> manager : Store breaker in map\nkey="auth-service"
else Breaker Exists
    manager -> manager : Return existing breaker
end

manager --> handler : Circuit breaker
deactivate manager

== State: CLOSED (Normal Operation) ==

loop Successful Requests
    handler -> breaker_auth : Execute(request)
    activate breaker_auth
    breaker_auth -> state : Check state
    activate state
    state --> breaker_auth : State: CLOSED
    deactivate state
    
    breaker_auth -> authsvc : Forward request
    activate authsvc
    authsvc -> authsvc : Process request
    authsvc --> breaker_auth : Success response
    deactivate authsvc
    
    breaker_auth -> state : Record success
    activate state
    state -> state : Success count++\nReset failure count
    state -> metrics : Update metrics\nstate=closed, success=true
    activate metrics
    metrics --> state : Recorded
    deactivate metrics
    state --> breaker_auth : Continue
    deactivate state
    
    breaker_auth --> handler : Success response
    deactivate breaker_auth
    handler -> handler : Return response to client
end

== Failures Start Occurring ==

handler -> breaker_auth : Execute(request 1)
activate breaker_auth
breaker_auth -> authsvc : Forward request
activate authsvc
authsvc -> authsvc : Error processing\n(timeout, connection refused, etc.)
authsvc --> breaker_auth : Error response
deactivate authsvc

breaker_auth -> state : Record failure
activate state
state -> state : Failure count: 1/3\nRequests: 1
note right
  Failure count tracked
  within the interval window
end note
state -> metrics : Update metrics\nstate=closed, failure=true
activate metrics
metrics --> state : Recorded
deactivate metrics
state --> breaker_auth : State: CLOSED (continue)
deactivate state

breaker_auth --> handler : Error response
deactivate breaker_auth
handler --> handler : Return 503 or error

handler -> breaker_auth : Execute(request 2)
activate breaker_auth
breaker_auth -> authsvc : Forward request
activate authsvc
authsvc --> breaker_auth : Error response
deactivate authsvc

breaker_auth -> state : Record failure
activate state
state -> state : Failure count: 2/3\nRequests: 2
state -> metrics : Update metrics
activate metrics
metrics --> state : Recorded
deactivate metrics
state --> breaker_auth : State: CLOSED (continue)
deactivate state

breaker_auth --> handler : Error response
deactivate breaker_auth

== State Transition: CLOSED -> OPEN ==

handler -> breaker_auth : Execute(request 3)
activate breaker_auth
breaker_auth -> authsvc : Forward request
activate authsvc
authsvc --> breaker_auth : Error response
deactivate authsvc

breaker_auth -> state : Record failure
activate state
state -> state : Failure count: 3/3\nRequests: 3\nFailure ratio: 100%

state -> state : Check ReadyToTrip condition:\n✓ Requests >= 3\n✓ Failure ratio >= 60%

state -> state : TRIP CIRCUIT!\nState: CLOSED -> OPEN\nStart timeout timer (30s)
note right
  Circuit trips to OPEN state:
  - Stop forwarding requests
  - Return immediate errors
  - Start timeout countdown
  - Give backend time to recover
end note

state -> metrics : Update metrics\nstate=open, reason=trip
activate metrics
metrics --> state : Recorded
deactivate metrics

state --> breaker_auth : State: OPEN
deactivate state

breaker_auth --> handler : Error: Circuit breaker is OPEN
deactivate breaker_auth
handler --> handler : Return 503 Service Unavailable

== State: OPEN (Failing Fast) ==

loop Requests during OPEN state
    handler -> breaker_auth : Execute(request)
    activate breaker_auth
    breaker_auth -> state : Check state
    activate state
    state --> breaker_auth : State: OPEN
    deactivate state
    
    breaker_auth -> breaker_auth : Fail immediately\n(no backend call)
    note right
      Fast fail during OPEN state:
      - No backend calls
      - Immediate error response
      - Protects backend from load
      - Saves resources
    end note
    
    breaker_auth -> metrics : Increment rejected requests
    activate metrics
    metrics --> breaker_auth : Recorded
    deactivate metrics
    
    breaker_auth --> handler : Error: Circuit breaker is OPEN
    deactivate breaker_auth
    handler --> handler : Return 503 Service Unavailable
end

== State Transition: OPEN -> HALF-OPEN ==

state -> state : Timeout elapsed (30s)
activate state
state -> state : State: OPEN -> HALF-OPEN\nAllow limited requests (3)\nTest backend recovery
note right
  HALF-OPEN state:
  - Allow 3 test requests
  - If successful -> CLOSED
  - If fail -> OPEN again
  - Gradual recovery
end note

state -> metrics : Update metrics\nstate=half_open
activate metrics
metrics --> state : Recorded
deactivate metrics
deactivate state

== State: HALF-OPEN (Testing Recovery) ==

handler -> breaker_auth : Execute(test request 1)
activate breaker_auth
breaker_auth -> state : Check state
activate state
state --> breaker_auth : State: HALF-OPEN\nAllowed requests: 1/3
deactivate state

breaker_auth -> authsvc : Forward request (carefully)
activate authsvc
authsvc -> authsvc : Process successfully
authsvc --> breaker_auth : Success response
deactivate authsvc

breaker_auth -> state : Record success
activate state
state -> state : Success count: 1\nRemaining allowed: 2/3
state --> breaker_auth : Continue testing
deactivate state

breaker_auth --> handler : Success response
deactivate breaker_auth

handler -> breaker_auth : Execute(test request 2)
activate breaker_auth
breaker_auth -> authsvc : Forward request
activate authsvc
authsvc --> breaker_auth : Success response
deactivate authsvc

breaker_auth -> state : Record success
activate state
state -> state : Success count: 2\nRemaining allowed: 1/3
state --> breaker_auth : Continue testing
deactivate state

breaker_auth --> handler : Success response
deactivate breaker_auth

handler -> breaker_auth : Execute(test request 3)
activate breaker_auth
breaker_auth -> authsvc : Forward request
activate authsvc
authsvc --> breaker_auth : Success response
deactivate authsvc

breaker_auth -> state : Record success
activate state
state -> state : Success count: 3\nAll test requests successful!

== State Transition: HALF-OPEN -> CLOSED ==

state -> state : State: HALF-OPEN -> CLOSED\nReset counters\nResume normal operation
note right
  Recovery successful:
  - All test requests passed
  - Circuit is CLOSED
  - Normal operation resumed
  - Backend is healthy
end note

state -> metrics : Update metrics\nstate=closed, reason=recovery
activate metrics
metrics --> state : Recorded
deactivate metrics

state --> breaker_auth : State: CLOSED
deactivate state

breaker_auth --> handler : Success response
deactivate breaker_auth

== Failure in HALF-OPEN State ==

note over handler, metrics
  If any request fails during HALF-OPEN state:
  - Circuit immediately returns to OPEN state
  - Timeout timer resets (another 30 seconds)
  - Backend needs more time to recover
  - Prevents premature recovery
end note

== Multiple Services with Independent Breakers ==

par Auth Service Circuit
    handler -> manager : GetBreaker("auth-service")
    activate manager
    manager --> handler : breaker_auth (CLOSED)
    deactivate manager
else User Service Circuit
    handler -> manager : GetBreaker("user-service")
    activate manager
    manager -> breaker_user : Create independent breaker
    activate breaker_user
    note right
      Each service has:
      - Independent circuit breaker
      - Separate state tracking
      - Isolated failure handling
      - No cascade effect
    end note
    breaker_user --> manager : breaker_user (CLOSED)
    deactivate breaker_user
    manager --> handler : breaker_user
    deactivate manager
end

note over handler, usersvc
  Service Isolation Benefits:
  - Auth service failure doesn't affect User service
  - User service can remain operational
  - Gradual degradation instead of total failure
  - Better system resilience
end note

== Metrics and Monitoring ==

note over metrics
  Prometheus Metrics Exported:
  
  - api_gateway_circuit_breaker_state{service="auth-service"}
    * Values: 0 (closed), 1 (half-open), 2 (open)
  
  - api_gateway_circuit_breaker_requests_total{service, result}
    * Labels: service, result (success/failure/rejected)
  
  - api_gateway_circuit_breaker_state_changes_total{service, from, to}
    * Track state transitions
  
  Monitor to:
  - Detect service degradation
  - Alert on circuit opening
  - Track recovery time
  - Identify problematic services
end note

@enduml
